# 本周学习笔记

学习路线:了解学习OpenZeppelin标准库=>基于此标准库的ERC20=>ERC20投票系统

## 1.OpenZeppelin标准库

OpenZeppelin 库是一套经过严格审计、高度模块化和可重用的solidity合约集合。它通过继承机制让自定义合约获得强大的基础功能，同时最小化安全风险。简单的说就是可以导入OpenZeppelin 库,然后继承他的功能.因为其中的所有合约都是经过了多年的安全审计和验证过的,被许多个项目使用过的,也就意味着基于这个库写的合约的逻辑相比自己纯手动编写的会更加严密,能消除更多的错误,避免了许多漏洞.同时,通过导入这个库也就继承了许多相应的功能,相比自己纯手动编写,其代码的简洁性也会更强.

而在本次的学习中主要学习和使用了以下三个合约

1. ERC20.sol,其作用是完整实现了ERC20代币标准接口.提供的核心功能有:
   - `transfer(to,value)`:用于转账功能
   - `approve(spender, value)`和`transferFrom(from, to, value)`,这两个函数通常作为一组来使用,用于owner授权其他地址代理自己来转账
   - `balanceOf(account)`,用来查询余额
   - `totalSupply()`,用来查询代币总量的
2. Ownable.sol,其作用是提供一个管理权限提供的核心功能有:
   - 存储一个owner地址
   - 提供了一个`onlyOwner`的修饰符,可以用来保护`mint`函数,确保只有owner可以调用`mint`函数
   - 还有两个管理函数分别是`transferOwnership()`和`renounceOwnership()`.前者是owner用来转换所有权的,即owner可以设置其他地址为owner;后者是owner可以放弃自己的所有权
3. ERC721.sol,其作用实现了ERC721代币的标准接口

除了有合约还有一些常用的扩展

- ERC20Burnable.sol它提供的功能是让用户可以销毁自己的代币,或者授权销毁的能力
- ERC20Capped.sol它提供的功能是在铸造的时候添加一个检查操作,确保totalSupply不超过设定的上限

---

## 遇到的问题

在写那个基于OpenZeppelin标准库的ERC20的时候,导入标准库过后显示了一个编译错误,原因是发生了一个多重继承继承冲突的错误.当我在继承了多个OpenZeppelin父合约时,`ERC20`和`ERC20Capped`这两个父合约,它们都定义了相同的核心内部函数`_update(address from, address to, uint256 value)`.

- `ERC20`中的`_update`实现了基础的逻辑,就是增加`to`地址的余额减少`from`地址的余额,然后更新`totalSupply`.
- `ERC20Capped`中的`_update`在内部逻辑中先检查总供应量是否超过`MAX_SUPPLY`然后再调用基础逻辑

当调用铸造函数的时候,编译器不知道执行哪个版本的`_update`,所以发生了错误.

---

## 解决方法

通过在子合约中显示重写这个冲突函数,使用`override`关键字列出定义了该函数的父合约,然后使用`super.function()`来指定应该调用哪个父合约的逻辑.

```solidity
//显式重写_update(),解决编译错误
    function _update(address from,address to,uint256 value) internal virtual override(ERC20,ERC20Capped){
        super._update(from,to,value);
    }
```

---

## 总结

本周深入学习了OpenZeppelin标准库,以及基于此标准库写了一个ERC20合约,但是在写代码的过程并不会顺利,遇到许多问题,并不能完全自己独立的写完整段代码,过程中及时与AI交互,最终也顺利完成了.在下周计划及时回看这周的代码,保证及时复习知识点,避免遗忘,增加熟练度.

在本周还尝试了搭建hardhat框架,但似乎Windows系统好像并不兼容,搞了好久没搞起,最终搭建好了Foundry框架,下周如果有多出来的时间计划学习一些如何利用Foundry来测试改写自己的代码

